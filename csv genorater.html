<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CSV Results Converter â€” Mountain State Miles</title>
<style>
  :root{--accent:#2d5a73;--accent-dark:#1a3a52;--bg:#f5f7fa;}
  body{font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(135deg, #e8f0f5 0%, #d0e0e8 100%);color:#222;padding:20px;min-height:100vh;}
  .container{max-width:1200px;margin:0 auto;}
  h1{color:var(--accent);margin:0 0 20px;font-size:2rem;font-weight:700;}
  .card{background:#fff;border-radius:12px;padding:20px;box-shadow:0 4px 12px rgba(0,0,0,0.08);margin-bottom:20px;}
  textarea{width:100%;min-height:250px;font-family:monospace;font-size:13px;padding:12px;border-radius:8px;border:2px solid #e0e0e0;box-sizing:border-box;transition:border-color 0.3s;}
  textarea:focus{outline:none;border-color:var(--accent);}
  .controls{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px;align-items:center;}
  button{background:var(--accent);color:#fff;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;font-weight:600;font-size:14px;transition:all 0.3s;}
  button:hover{background:var(--accent-dark);transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,0.15);}
  button.secondary{background:#6c757d;color:#fff;}
  button.secondary:hover{background:#5a6268;}
  table{width:100%;border-collapse:collapse;margin-top:15px;background:#fff;border-radius:8px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.05);}
  th,td{padding:10px;border:1px solid #e9ecef;text-align:left;font-size:13px;}
  th{background:linear-gradient(135deg,var(--accent) 0%,var(--accent-dark) 100%);color:#fff;font-weight:600;text-transform:uppercase;font-size:12px;letter-spacing:0.5px;}
  tbody tr:nth-child(even){background:#f8f9fa;}
  tbody tr:hover{background:#e9ecef;}
  .small{font-size:13px;color:#6c757d;margin-top:8px;}
  label{font-size:14px;font-weight:500;color:#495057;display:flex;align-items:center;gap:8px;}
  select{padding:6px 10px;border-radius:6px;border:1px solid #ced4da;font-size:14px;background:#fff;}
  #downloadBtn{display:none;}
  .status{display:inline-block;padding:6px 12px;border-radius:6px;font-size:12px;font-weight:600;margin-top:8px;}
  .status.success{background:#d4edda;color:#155724;}
  .status.error{background:#f8d7da;color:#721c24;}
  .status.info{background:#d1ecf1;color:#0c5460;}
  .url-input-group{display:flex;gap:8px;margin-bottom:12px;align-items:stretch;}
  .url-input-group input{flex:1;padding:10px 12px;border-radius:8px;border:2px solid #e0e0e0;font-size:14px;box-sizing:border-box;}
  .url-input-group input:focus{outline:none;border-color:var(--accent);}
  .url-input-group button{white-space:nowrap;}
  button:disabled{opacity:0.6;cursor:not-allowed;transform:none !important;}
</style>
</head>
<body>
<div class="container">
<h1>CSV Results Converter</h1>
<div class="small" style="margin-bottom:20px;">Paste results from any source (MileSplit, AthleticLIVE, RunSignUp, RunWV, chip-timing systems, HTML tables, etc.) and convert to standardized CSV format.</div>

<div class="card">
  <div class="controls">
    <label>Gender:
      <select id="gender"><option value="F">Female</option><option value="M">Male</option></select>
    </label>

    <label>Default distance:
      <select id="defaultDistance">
        <option value="5000">5,000 m (5K)</option>
        <option value="3000">3,000 m (3K)</option>
        <option value="3200">3,200 m</option>
        <option value="1600">1,600 m (Mile)</option>
        <option value="0">Auto-detect</option>
      </select>
    </label>

    <button id="parseBtn">Parse & Convert</button>
    <button id="clearBtn" class="secondary">Clear All</button>
    <button id="downloadBtn">Download CSV</button>
  </div>
  <div id="status"></div>
</div>

<div class="card">
  <div style="margin-bottom:12px;">
    <label style="display:block;margin-bottom:8px;font-weight:600;">Or paste a results page URL:</label>
    <div class="url-input-group">
      <input type="url" id="urlInput" placeholder="https://www.milesplit.com/meets/..." />
      <button id="fetchUrlBtn">Fetch & Parse</button>
    </div>
    <div class="small">Supports MileSplit, AthleticLIVE, RunSignUp, and other results pages.</div>
  </div>
  
  <textarea id="input" placeholder="Paste results here â€” supports HTML tables, plain text, CSV, tab-separated, or any mixed format.

Examples:
â€¢ Copy entire HTML table from results page
â€¢ Paste plain text results
â€¢ Copy from Excel/Spreadsheet
â€¢ Paste from chip timing system exports
â€¢ Or use the URL input above to fetch directly"></textarea>
  <div class="small">ðŸ’¡ Tip: The parser automatically detects format and extracts athlete names, schools, times, and places.</div>
</div>

<div class="card">
  <h2 style="margin-top:0;font-size:1.3rem;color:var(--accent);">Parsed Results</h2>
  <div style="overflow-x:auto;">
    <table id="outputTable">
      <tr><td colspan="6" class="small" style="text-align:center;padding:20px;">No results parsed yet. Paste your data and click "Parse & Convert".</td></tr>
    </table>
  </div>
</div>
</div>

<script>
/* ============================================
   Configuration & School Name Mappings
   ============================================ */
const schoolOverrides = {
  "woodrow wilson": "woodrow",
  "park. south": "parkersburg-south",
  "parkersburg south": "parkersburg-south",
  "buck-upshur": "buckhannon",
  "buckhannon-upshur": "buckhannon",
  "geo. washington": "george-washington",
  "george washington": "george-washington",
  "parkersburg": "parkersburg",
  "cabell midland": "cabell-midland",
  "wheeling park": "wheeling-park",
  "oak hill": "oak-hill",
  "spring mills": "spring-mills"
};

/* ============================================
   Utility Functions
   ============================================ */
function decodeHTMLEntities(str) {
  if (!str) return "";
  const t = document.createElement('textarea');
  t.innerHTML = str;
  return t.value.trim();
}

function slugifySchool(name) {
  if (!name) return "";
  const n = decodeHTMLEntities(String(name)).trim().toLowerCase();
  // Check overrides first
  for (const k in schoolOverrides) {
    if (n.includes(k)) return schoolOverrides[k];
  }
  // Default slugification
  return n.replace(/&amp;|&/g, 'and')
          .replace(/\s+/g, '-')
          .replace(/[^a-z0-9-]/g, '');
}

function cleanTimeToken(t) {
  if (!t) return "";
  return String(t).replace(/\*/g, '')
                   .replace(/PR\b|SB\b|PB\b/gi, '')
                   .replace(/,/g, '.')
                   .replace(/[^\d:.]/g, '')
                   .trim();
}

function timeToSeconds(timeStr) {
  if (!timeStr) return null;
  const cleaned = cleanTimeToken(timeStr);
  if (!cleaned) return null;
  
  try {
    const parts = cleaned.split(':').map(s => s.trim());
    
    if (parts.length === 3) {
      // H:MM:SS or H:MM:SS.xx
      const h = parseFloat(parts[0]) || 0;
      const m = parseFloat(parts[1]) || 0;
      const s = parseFloat(parts[2]) || 0;
      if (!isNaN(h) && !isNaN(m) && !isNaN(s)) {
        return parseFloat((h * 3600 + m * 60 + s).toFixed(2));
      }
    } else if (parts.length === 2) {
      // MM:SS or MM:SS.xx
      const m = parseFloat(parts[0]) || 0;
      const s = parseFloat(parts[1]) || 0;
      if (!isNaN(m) && !isNaN(s)) {
        return parseFloat((m * 60 + s).toFixed(2));
      }
    } else if (parts.length === 1) {
      // Just seconds (e.g., "123.45")
      const num = parseFloat(parts[0]);
      if (!isNaN(num)) return parseFloat(num.toFixed(2));
    }
  } catch (e) {
    console.warn('Time parsing error:', e, timeStr);
  }
  
  return null;
}

function detectDistance(text, defaultDistance) {
  if (defaultDistance && defaultDistance !== "0") return Number(defaultDistance);
  const s = (text || '').toLowerCase();
  if (/\b5\s?k\b|\b5000\b|\b5,000\b/.test(s)) return 5000;
  if (/\b3\s?k\b|\b3000\b|\b3,000\b/.test(s)) return 3000;
  if (/\b3200\b|\b3,200\b/.test(s)) return 3200;
  if (/\b1600\b|\b1,600\b|\bmile\b|\b1\s?mile\b/.test(s)) return 1600;
  return 5000; // Default
}

function showStatus(message, type = 'info') {
  const statusEl = document.getElementById('status');
  statusEl.innerHTML = `<span class="status ${type}">${message}</span>`;
  if (type === 'success' || type === 'error') {
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
  }
}

/* ============================================
   HTML Table Parser
   ============================================ */
function parseHTMLTables(raw) {
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(raw, 'text/html');
    const tables = doc.querySelectorAll('table');
    
    if (tables.length === 0) return null;
    
    const results = [];
    
    tables.forEach(table => {
      const rows = table.querySelectorAll('tr');
      let headerRow = null;
      let nameIdx = -1;
      let teamIdx = -1;
      let timeIdx = -1;
      let placeIdx = -1;
      
      rows.forEach((row, rowIdx) => {
        const cells = Array.from(row.querySelectorAll('th, td')).map(c => 
          decodeHTMLEntities(c.textContent).trim()
        ).filter(Boolean);
        
        if (cells.length === 0) return;
        
        // Detect and parse header row
        if (rowIdx === 0 || row.querySelector('th')) {
          headerRow = cells.map(c => c.toLowerCase());
          
          // Find column indices from headers
          headerRow.forEach((header, idx) => {
            const h = header.toLowerCase();
            if ((h.includes('name') || h.includes('athlete') || h.includes('runner')) && !h.includes('team')) {
              nameIdx = idx;
            }
            if (h.includes('team') || h.includes('school') || h.includes('club') || h.includes('affiliation')) {
              teamIdx = idx;
            }
            if (h.includes('time') || h.includes('finish') || h.includes('result')) {
              timeIdx = idx;
            }
            if (h.includes('place') || h.includes('rank') || h.includes('pos') || h.includes('#')) {
              placeIdx = idx;
            }
          });
          
          // If we found headers, try to find time column by pattern
          if (timeIdx === -1) {
            for (let i = 0; i < cells.length; i++) {
              if (/\d{1,2}:\d{2}(?::\d{2})?(?:\.\d+)?/.test(cells[i])) {
                timeIdx = i;
                break;
              }
            }
          }
          
          return; // Skip header row
        }
        
        // For data rows, use header indices if available
        let timeValue = null;
        let actualTimeIdx = timeIdx;
        
        // Find time column (either from header or by pattern)
        if (actualTimeIdx === -1) {
          for (let i = 0; i < cells.length; i++) {
            if (/\d{1,2}:\d{2}(?::\d{2})?(?:\.\d+)?/.test(cells[i])) {
              actualTimeIdx = i;
              timeValue = cells[i];
              break;
            }
          }
        } else {
          timeValue = cells[actualTimeIdx];
        }
        
        if (actualTimeIdx === -1 || !timeValue) return; // Skip rows without time
        
        // Extract place
        let place = '';
        if (placeIdx >= 0 && placeIdx < cells.length) {
          const placeMatch = cells[placeIdx].match(/^(\d+)/);
          if (placeMatch) place = parseInt(placeMatch[1], 10);
        }
        if (!place && cells[0]) {
          const placeMatch = cells[0].match(/^(\d+)/);
          if (placeMatch) place = parseInt(placeMatch[1], 10);
        }
        
        // Extract name using header index if available
        let name = '';
        if (nameIdx >= 0 && nameIdx < cells.length) {
          name = cells[nameIdx].trim();
        } else {
          // Fallback: extract name from columns before time
          let nameParts = [];
          for (let i = 0; i < actualTimeIdx; i++) {
            const cell = cells[i];
            // Skip place, bib, grade columns
            if (i === placeIdx) continue;
            if (/^\d+$/.test(cell) || /^(FR|SO|JR|SR)$/i.test(cell)) continue;
            if (/^\d+[A-Z]?$/.test(cell)) continue;
            // Skip if this is the team column
            if (i === teamIdx) continue;
            nameParts.push(cell);
          }
          name = nameParts.join(' ').trim();
        }
        
        // Extract school/team using header index if available
        let school = '';
        if (teamIdx >= 0 && teamIdx < cells.length) {
          school = cells[teamIdx].trim();
        } else {
          // Fallback: look for school after time first
          let schoolParts = [];
          for (let i = actualTimeIdx + 1; i < cells.length; i++) {
            const cell = cells[i];
            if (/\d{1,2}:\d{2}/.test(cell)) continue;
            if (/^\d+$/.test(cell)) continue;
            schoolParts.push(cell);
          }
          
          // If no school found after time, check before time
          if (schoolParts.length === 0) {
            for (let i = 0; i < actualTimeIdx; i++) {
              const cell = cells[i];
              // Skip if it's name, place, bib, or grade
              if (i === nameIdx || i === placeIdx) continue;
              if (/^\d+$/.test(cell) || /^(FR|SO|JR|SR)$/i.test(cell)) continue;
              if (/^\d+[A-Z]?$/.test(cell)) continue;
              // This might be the team
              schoolParts.push(cell);
            }
          }
          
          school = schoolParts.join(' ').trim();
        }
        
        // Clean up name - remove any team/school that might have been included
        if (name && school) {
          // Remove school name from name if it appears at the end
          const schoolWords = school.split(/\s+/);
          schoolWords.forEach(word => {
            if (word.length > 3) {
              const regex = new RegExp('\\b' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
              name = name.replace(regex, '').trim();
            }
          });
          name = name.replace(/\s{2,}/g, ' ').trim();
        }
        
        if (name && timeValue) {
          results.push({
            athlete_name: name,
            school_slug: slugifySchool(school),
            gender: '',
            time: timeToSeconds(timeValue),
            distance: detectDistance(raw, 0),
            place: place || ''
          });
        }
      });
    });
    
    return results.length > 0 ? results : null;
  } catch (e) {
    console.warn('HTML parsing error:', e);
    return null;
  }
}

/* ============================================
   Delimited Text Parser (CSV, TSV, etc.)
   ============================================ */
function parseDelimitedText(raw) {
  const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  if (lines.length < 2) return null;
  
  const results = [];
  const delimiter = raw.includes('\t') ? '\t' : (raw.includes(',') ? ',' : null);
  
  if (!delimiter) return null;
  
  let nameIdx = -1;
  let teamIdx = -1;
  let timeIdx = -1;
  let placeIdx = -1;
  let hasHeader = false;
  
  lines.forEach((line, idx) => {
    const cells = line.split(delimiter).map(c => c.replace(/^["']|["']$/g, '').trim());
    
    if (cells.length < 2) return;
    
    // Detect and parse header row
    if (idx === 0 && cells.some(c => /name|athlete|time|place|school|team|rank/i.test(c))) {
      hasHeader = true;
      const headerRow = cells.map(c => c.toLowerCase());
      
      // Find column indices from headers
      headerRow.forEach((header, i) => {
        const h = header.toLowerCase();
        if ((h.includes('name') || h.includes('athlete') || h.includes('runner')) && !h.includes('team')) {
          nameIdx = i;
        }
        if (h.includes('team') || h.includes('school') || h.includes('club') || h.includes('affiliation')) {
          teamIdx = i;
        }
        if (h.includes('time') || h.includes('finish') || h.includes('result')) {
          timeIdx = i;
        }
        if (h.includes('place') || h.includes('rank') || h.includes('pos') || h === '#') {
          placeIdx = i;
        }
      });
      
      // If time column not found in header, try pattern matching
      if (timeIdx === -1) {
        for (let i = 0; i < cells.length; i++) {
          if (/\d{1,2}:\d{2}(?::\d{2})?(?:\.\d+)?/.test(cells[i])) {
            timeIdx = i;
            break;
          }
        }
      }
      
      return; // Skip header row
    }
    
    // Find time column if not already set
    let timeValue = null;
    let actualTimeIdx = timeIdx;
    
    if (actualTimeIdx === -1) {
      for (let i = 0; i < cells.length; i++) {
        if (/\d{1,2}:\d{2}(?::\d{2})?(?:\.\d+)?/.test(cells[i])) {
          actualTimeIdx = i;
          timeValue = cells[i];
          break;
        }
      }
    } else {
      timeValue = cells[actualTimeIdx];
    }
    
    if (actualTimeIdx === -1 || !timeValue) return;
    
    // Extract place
    let place = '';
    if (placeIdx >= 0 && placeIdx < cells.length) {
      const placeMatch = cells[placeIdx].match(/^(\d+)/);
      if (placeMatch) place = parseInt(placeMatch[1], 10);
    }
    if (!place && cells[0]) {
      const placeMatch = cells[0].match(/^(\d+)/);
      if (placeMatch) place = parseInt(placeMatch[1], 10);
    }
    
    // Extract name using header index if available
    let name = '';
    if (nameIdx >= 0 && nameIdx < cells.length) {
      name = cells[nameIdx].trim();
    } else {
      // Fallback: extract name from columns before time
      let nameParts = [];
      for (let i = 0; i < actualTimeIdx; i++) {
        const cell = cells[i];
        if (i === placeIdx) continue;
        if (/^\d+$/.test(cell) || /^(FR|SO|JR|SR)$/i.test(cell)) continue;
        if (/^\d+[A-Z]?$/.test(cell)) continue;
        if (i === teamIdx) continue;
        nameParts.push(cell);
      }
      name = nameParts.join(' ').trim();
    }
    
    // Extract school/team using header index if available
    let school = '';
    if (teamIdx >= 0 && teamIdx < cells.length) {
      school = cells[teamIdx].trim();
    } else {
      // Fallback: look for school after time first
      let schoolParts = [];
      for (let i = actualTimeIdx + 1; i < cells.length; i++) {
        const cell = cells[i];
        if (/\d{1,2}:\d{2}/.test(cell)) continue;
        if (/^\d+$/.test(cell)) continue;
        schoolParts.push(cell);
      }
      
      // If no school found after time, check before time
      if (schoolParts.length === 0) {
        for (let i = 0; i < actualTimeIdx; i++) {
          const cell = cells[i];
          if (i === nameIdx || i === placeIdx) continue;
          if (/^\d+$/.test(cell) || /^(FR|SO|JR|SR)$/i.test(cell)) continue;
          if (/^\d+[A-Z]?$/.test(cell)) continue;
          schoolParts.push(cell);
        }
      }
      
      school = schoolParts.join(' ').trim();
    }
    
    // Clean up name - remove any team/school that might have been included
    if (name && school) {
      const schoolWords = school.split(/\s+/);
      schoolWords.forEach(word => {
        if (word.length > 3) {
          const regex = new RegExp('\\b' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
          name = name.replace(regex, '').trim();
        }
      });
      name = name.replace(/\s{2,}/g, ' ').trim();
    }
    
    if (name && timeValue) {
      results.push({
        athlete_name: name,
        school_slug: slugifySchool(school),
        gender: '',
        time: timeToSeconds(timeValue),
        distance: detectDistance(raw, 0),
        place: place || ''
      });
    }
  });
  
  return results.length > 0 ? results : null;
}

/* ============================================
   Line-by-Line Parser (for unstructured text)
   ============================================ */
function parseLineByLine(raw, gender, defaultDistance) {
  const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  if (lines.length < 2) return null;
  
  const results = [];
  const timePattern = /\d{1,2}:\d{2}(?::\d{2})?(?:\.\d+)?/;
  
  lines.forEach(line => {
    // Find time in line
    const timeMatch = line.match(timePattern);
    if (!timeMatch) return;
    
    const timeValue = timeMatch[0];
    const timeIndex = timeMatch.index;
    
    // Split line around time
    const beforeTime = line.substring(0, timeIndex).trim();
    const afterTime = line.substring(timeIndex + timeValue.length).trim();
    
    // Extract place
    let place = '';
    const placeMatch = beforeTime.match(/^(\d+)(?:\s|$|\(|\.)/);
    if (placeMatch) place = parseInt(placeMatch[1], 10);
    
    // Extract name (remove place, bib, grade)
    let name = beforeTime
      .replace(/^\d+\s*/, '')
      .replace(/\s+\d+\s*$/, '')
      .replace(/\b(FR|SO|JR|SR)\b/gi, '')
      .trim();
    
    // Extract school
    let school = afterTime
      .replace(/^\d+\s*/, '')
      .split(/\s{2,}|\t/)[0]
      .trim();
    
    // If school empty, try to extract from end of beforeTime
    if (!school && beforeTime) {
      const parts = beforeTime.split(/\s{2,}|\t|,/).filter(Boolean);
      if (parts.length > 1) {
        school = parts[parts.length - 1];
        name = parts.slice(0, -1).join(' ').replace(/\b(FR|SO|JR|SR)\b/gi, '').trim();
      }
    }
    
    if (name && timeValue) {
      results.push({
        athlete_name: name,
        school_slug: slugifySchool(school),
        gender: gender || '',
        time: timeToSeconds(timeValue),
        distance: detectDistance(raw, defaultDistance),
        place: place || ''
      });
    }
  });
  
  return results.length > 0 ? results : null;
}

/* ============================================
   Mashed/No-Space Parser (for continuous text)
   ============================================ */
function parseMashedFormat(raw, gender, defaultDistance) {
  const text = raw.trim();
  const whitespaceRatio = (text.match(/\s/g) || []).length / Math.max(1, text.length);
  
  // If very few spaces, it's likely mashed
  if (whitespaceRatio > 0.1) return null;
  
  const results = [];
  const timePattern = /\d{1,2}:\d{2}(?::\d{2})?(?:\.\d+)?/g;
  const matches = [...text.matchAll(timePattern)];
  
  if (matches.length === 0) return null;
  
  matches.forEach((match, idx) => {
    const timeValue = match[0];
    const timeIndex = match.index;
    
    const prevEnd = idx === 0 ? 0 : matches[idx - 1].index + matches[idx - 1][0].length;
    const nextStart = idx < matches.length - 1 ? matches[idx + 1].index : text.length;
    
    const beforeTime = text.substring(prevEnd, timeIndex).trim();
    const afterTime = text.substring(timeIndex + timeValue.length, nextStart).trim();
    
    // Extract place
    let place = '';
    const placeMatch = beforeTime.match(/(\d+)(?=\d|$)/);
    if (placeMatch) place = parseInt(placeMatch[1], 10);
    
    // Extract name (remove leading digits, grades)
    let name = beforeTime
      .replace(/^\d+/, '')
      .replace(/\b(FR|SO|JR|SR)\b/gi, '')
      .replace(/^\d+/, '')
      .trim();
    
    // Extract school
    let school = afterTime
      .replace(/^\d+/, '')
      .split(/[A-Z][a-z]/)[0]
      .trim();
    
    // If school looks like next record, truncate
    if (school.match(/^\d+[A-Z]/)) {
      school = '';
    }
    
    if (name && timeValue) {
      results.push({
        athlete_name: name,
        school_slug: slugifySchool(school),
        gender: gender || '',
        time: timeToSeconds(timeValue),
        distance: detectDistance(raw, defaultDistance),
        place: place || ''
      });
    }
  });
  
  return results.length > 0 ? results : null;
}

/* ============================================
   Master Parser
   ============================================ */
function universalParse(raw, gender, defaultDistance) {
  if (!raw || !raw.trim()) {
    showStatus('No input provided', 'error');
    return [];
  }
  
  // Try HTML tables first
  if (/<table|<tr|<td|<tbody/i.test(raw)) {
    const htmlResult = parseHTMLTables(raw);
    if (htmlResult && htmlResult.length > 0) {
      showStatus(`âœ“ Parsed ${htmlResult.length} results from HTML table`, 'success');
      return htmlResult;
    }
  }
  
  // Try delimited text (CSV/TSV)
  const delimitedResult = parseDelimitedText(raw);
  if (delimitedResult && delimitedResult.length > 0) {
    showStatus(`âœ“ Parsed ${delimitedResult.length} results from delimited text`, 'success');
    return delimitedResult;
  }
  
  // Try mashed format
  const mashedResult = parseMashedFormat(raw, gender, defaultDistance);
  if (mashedResult && mashedResult.length > 0) {
    showStatus(`âœ“ Parsed ${mashedResult.length} results from continuous text`, 'success');
    return mashedResult;
  }
  
  // Try line-by-line
  const lineResult = parseLineByLine(raw, gender, defaultDistance);
  if (lineResult && lineResult.length > 0) {
    showStatus(`âœ“ Parsed ${lineResult.length} results from text lines`, 'success');
    return lineResult;
  }
  
  showStatus('Could not parse results. Please check your input format.', 'error');
  return [];
}

/* ============================================
   CSV Generation & Display
   ============================================ */
function renderAndEnableDownload(results, gender) {
  const table = document.getElementById('outputTable');
  table.innerHTML = '';
  
  if (!results || results.length === 0) {
    table.innerHTML = '<tr><td colspan="6" class="small" style="text-align:center;padding:20px;">No results to display.</td></tr>';
    document.getElementById('downloadBtn').style.display = 'none';
    return;
  }
  
  // Add gender to results if not set
  results.forEach(r => {
    if (!r.gender && gender) r.gender = gender;
  });
  
  // Build table header
  const header = document.createElement('tr');
  ['Place', 'Athlete Name', 'School', 'Gender', 'Time (sec)', 'Distance (m)'].forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    header.appendChild(th);
  });
  table.appendChild(header);
  
  // Build CSV rows
  const csvRows = ['athlete_name,school_slug,gender,time,distance,place'];
  
  // Sort by time if available, otherwise keep original order
  const sortedResults = [...results].sort((a, b) => {
    const aTime = (typeof a.time === 'number' && !isNaN(a.time)) ? a.time : Infinity;
    const bTime = (typeof b.time === 'number' && !isNaN(b.time)) ? b.time : Infinity;
    return aTime - bTime;
  });
  
  // Assign sequential places if missing
  sortedResults.forEach((r, idx) => {
    if (!r.place && typeof r.time === 'number' && !isNaN(r.time)) {
      r.place = idx + 1;
    }
  });
  
  // Render table rows
  sortedResults.forEach(r => {
    const tr = document.createElement('tr');
    const place = r.place || '';
    const name = r.athlete_name || '';
    const school = r.school_slug || '';
    const rgender = r.gender || '';
    const time = (typeof r.time === 'number' && !isNaN(r.time)) ? r.time.toFixed(2) : '';
    const distance = r.distance || '';
    
    [place, name, school, rgender, time, distance].forEach(val => {
      const td = document.createElement('td');
      td.textContent = val;
      tr.appendChild(td);
    });
    
    table.appendChild(tr);
    
    // Add to CSV
    const csvValues = [name, school, rgender, time, distance, place].map(v => {
      const s = String(v || '');
      return `"${s.replace(/"/g, '""')}"`;
    });
    csvRows.push(csvValues.join(','));
  });
  
  // Enable download button
  const csv = csvRows.join('\n');
  const btn = document.getElementById('downloadBtn');
  btn.style.display = 'inline-block';
  btn.onclick = () => {
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'results.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showStatus('CSV downloaded successfully!', 'success');
  };
}

/* ============================================
   URL Fetching
   ============================================ */
async function fetchFromUrl(url) {
  if (!url || !url.trim()) {
    showStatus('Please enter a valid URL', 'error');
    return;
  }
  
  // Normalize URL
  let normalizedUrl = url.trim();
  if (!normalizedUrl.startsWith('http://') && !normalizedUrl.startsWith('https://')) {
    normalizedUrl = 'https://' + normalizedUrl;
  }
  
  const btn = document.getElementById('fetchUrlBtn');
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Fetching...';
  showStatus('Fetching page...', 'info');
  
  try {
    // Try direct fetch first
    let response;
    try {
      response = await fetch(normalizedUrl, {
        method: 'GET',
        mode: 'cors',
        headers: {
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const html = await response.text();
      
      // Put HTML in textarea and auto-parse
      document.getElementById('input').value = html;
      showStatus('âœ“ Page fetched successfully! Parsing...', 'success');
      
      // Auto-parse after a brief delay
      setTimeout(() => {
        const gender = document.getElementById('gender').value;
        const defaultDistance = document.getElementById('defaultDistance').value;
        const results = universalParse(html, gender, defaultDistance);
        renderAndEnableDownload(results, gender);
      }, 500);
      
      btn.disabled = false;
      btn.textContent = originalText;
      return;
    } catch (directError) {
      // Direct fetch failed, try CORS proxy
      console.log('Direct fetch failed, trying CORS proxy...', directError);
      
      // Try multiple CORS proxy services
      const corsProxies = [
        `https://api.allorigins.win/get?url=${encodeURIComponent(normalizedUrl)}`,
        `https://corsproxy.io/?${encodeURIComponent(normalizedUrl)}`,
      ];
      
      let proxySuccess = false;
      for (const proxyUrl of corsProxies) {
        try {
          showStatus('Using CORS proxy...', 'info');
          response = await fetch(proxyUrl, {
            method: 'GET',
            mode: 'cors'
          });
          
          if (!response.ok) continue;
          
          let html;
          if (proxyUrl.includes('allorigins.win')) {
            const data = await response.json();
            html = data.contents;
          } else {
            html = await response.text();
          }
          
          // Put HTML in textarea and auto-parse
          document.getElementById('input').value = html;
          showStatus('âœ“ Page fetched via proxy! Parsing...', 'success');
          
          setTimeout(() => {
            const gender = document.getElementById('gender').value;
            const defaultDistance = document.getElementById('defaultDistance').value;
            const results = universalParse(html, gender, defaultDistance);
            renderAndEnableDownload(results, gender);
          }, 500);
          
          proxySuccess = true;
          btn.disabled = false;
          btn.textContent = originalText;
          return;
        } catch (proxyError) {
          console.log('Proxy failed:', proxyError);
          continue;
        }
      }
      
      if (!proxySuccess) {
        throw new Error('Unable to fetch page. CORS restrictions may apply. Try copying the page content manually.');
      }
    }
  } catch (error) {
    console.error('Fetch error:', error);
    showStatus(`Error: ${error.message || 'Failed to fetch page. Try copying the page content manually.'}`, 'error');
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

/* ============================================
   Event Handlers
   ============================================ */
document.getElementById('fetchUrlBtn').addEventListener('click', async () => {
  const url = document.getElementById('urlInput').value;
  await fetchFromUrl(url);
});

// Allow Enter key in URL input
document.getElementById('urlInput').addEventListener('keypress', async (e) => {
  if (e.key === 'Enter') {
    const url = document.getElementById('urlInput').value;
    await fetchFromUrl(url);
  }
});

document.getElementById('parseBtn').addEventListener('click', () => {
  const raw = document.getElementById('input').value || '';
  const gender = document.getElementById('gender').value;
  const defaultDistance = document.getElementById('defaultDistance').value;
  
  showStatus('Parsing...', 'info');
  
  const results = universalParse(raw, gender, defaultDistance);
  renderAndEnableDownload(results, gender);
});

document.getElementById('clearBtn').addEventListener('click', () => {
  document.getElementById('input').value = '';
  document.getElementById('urlInput').value = '';
  document.getElementById('outputTable').innerHTML = '<tr><td colspan="6" class="small" style="text-align:center;padding:20px;">Cleared. Paste new input.</td></tr>';
  document.getElementById('downloadBtn').style.display = 'none';
  document.getElementById('status').innerHTML = '';
});
</script>
</body>
</html>
