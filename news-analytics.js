/**
 * News Analytics Engine
 * Automatically generates meet recaps and summaries by analyzing results
 */

class MeetAnalytics {
  constructor(database) {
    this.db = database;
  }

  /**
   * Generate a summary for a meet based on its results
   * @param {string} sport - 'track' or 'xc'
   * @param {string} meetId - The meet ID/slug
   * @returns {Promise<Object>} The generated summary
   */
  async generateMeetSummary(sport, meetId) {
    try {
      // Use consistent database prefix (crosscountry is lowercase in DB)
      const prefix = sport === 'track' ? 'Track' : 'crosscountry';
      const meetsRef = `${prefix}/meets`;
      const resultsRefBase = `${prefix}/results`;

      // Try to read meet by ID first
      let meetSnapshot = await this.db.ref(`${meetsRef}/${meetId}`).once('value');
      let meetData = meetSnapshot.val();
      let actualMeetId = meetId;

      // If not found, try to find by slug
      if (!meetData) {
        const bySlugSnap = await this.db.ref(meetsRef).orderByChild('slug').equalTo(meetId).once('value');
        const found = [];
        bySlugSnap.forEach(child => found.push({ id: child.key, ...child.val() }));
        if (found.length > 0) {
          meetData = found[0];
          actualMeetId = found[0].id;
        }
      }

      if (!meetData) {
        throw new Error(`Meet '${meetId}' not found in ${meetsRef}`);
      }

      // Try to get results stored under a meet-specific node (results/{meetId})
      let results = [];
      const groupedResultsSnap = await this.db.ref(`${resultsRefBase}/${actualMeetId}`).once('value');
      if (groupedResultsSnap.exists()) {
        groupedResultsSnap.forEach(child => {
          results.push({ athleteId: child.key, ...child.val() });
        });
      } else {
        // Fallback: results may be stored as a flat list with a meet_slug property
        const slugToQuery = meetData.slug || actualMeetId;
        const bySlugResultsSnap = await this.db.ref(resultsRefBase).orderByChild('meet_slug').equalTo(slugToQuery).once('value');
        bySlugResultsSnap.forEach(child => results.push({ athleteId: child.key, ...child.val() }));
      }

      if (results.length === 0) {
        return null; // No results yet
      }

      // Analyze the results
      const analysis = this._analyzeResults(meetData, results, sport);

      return {
        title: `${meetData.name} ‚Äî Meet Recap`,
        date: new Date().toISOString().split('T')[0],
        meetName: meetData.name,
        sport: sport === 'track' ? 'Track' : 'Cross Country',
        type: 'Auto-Generated',
        meetId: actualMeetId,
        summary: analysis.summary,
        highlights: analysis.highlights,
        standoutAthletes: analysis.standoutAthletes,
        teamPerformance: analysis.teamPerformance,
        metadata: {
          totalAthletes: results.length,
          analysisDate: new Date().toISOString(),
          autoGenerated: true
        }
      };
    } catch (error) {
      console.error('Error generating summary:', error);
      throw error;
    }
  }

  /**
   * Analyze results and extract insights
   * @private
   */
  _analyzeResults(meetData, results, sport) {
    const standoutAthletes = [];
    const teamPerformance = {};
    const highlights = [];

    // Group results by team
    const byTeam = {};
    results.forEach(result => {
      const team = result.team || result.school || 'Unknown';
      if (!byTeam[team]) {
        byTeam[team] = [];
      }
      byTeam[team].push(result);
    });

    // Analyze individual performances
    const topPerformers = this._findTopPerformers(results, sport);
    topPerformers.forEach(athlete => {
      standoutAthletes.push(
        `${athlete.name || 'Athlete'} (${athlete.team || athlete.school || 'Unknown'}) ‚Äî ${this._formatPerformance(athlete, sport)}`
      );
    });

    // Analyze team performance
    const teamStats = this._analyzeTeamPerformance(byTeam, sport);

    // Generate summary text
    const summary = this._generateSummaryText(meetData, topPerformers, teamStats, sport);

    // Generate highlights
    highlights.push(...this._generateHighlights(topPerformers, teamStats, sport));

    return {
      summary,
      highlights: highlights.join('\n'),
      standoutAthletes,
      teamPerformance: teamStats
    };
  }

  /**
   * Find top performing athletes
   * @private
   */
  _findTopPerformers(results, sport) {
    const sorted = [...results];

    if (sport === 'track') {
      // For track, sort by time (lower is better) for distance events
      // or by distance for field events
      sorted.sort((a, b) => {
        const aTime = parseFloat(a.time) || 0;
        const bTime = parseFloat(b.time) || 0;
        return aTime - bTime;
      });
    } else {
      // For XC, sort by time ascending (lower is better)
      sorted.sort((a, b) => {
        const aTime = parseFloat(a.time) || Infinity;
        const bTime = parseFloat(b.time) || Infinity;
        return aTime - bTime;
      });
    }

    return sorted.slice(0, 5); // Top 5
  }

  /**
   * Analyze team performance and get predictions
   * @private
   */
  _analyzeTeamPerformance(byTeam, sport) {
    const teamStats = {};

    Object.entries(byTeam).forEach(([team, athletes]) => {
      const totalTime = athletes.reduce((sum, a) => {
        return sum + (parseFloat(a.time) || 0);
      }, 0);

      const avgTime = totalTime / athletes.length;
      const topAthletes = athletes
        .sort((a, b) => (parseFloat(a.time) || 0) - (parseFloat(b.time) || 0))
        .slice(0, 7);

      teamStats[team] = {
        athletes: athletes.length,
        avgTime: avgTime.toFixed(2),
        topAthletes: topAthletes.length,
        score: sport === 'xc' ? this._calculateXCScore(topAthletes) : undefined
      };
    });

    return teamStats;
  }

  /**
   * Calculate cross country score (sum of top 7 finishes)
   * @private
   */
  _calculateXCScore(athletes) {
    return athletes.reduce((sum, athlete, idx) => sum + (idx + 1), 0);
  }

  /**
   * Format a performance for display
   * @private
   */
  _formatPerformance(athlete, sport) {
    if (sport === 'track') {
      return `${athlete.event || 'Event'} ‚Äî ${athlete.time || 'Time TBD'}`;
    } else {
      return `${athlete.time || 'Time TBD'}`;
    }
  }

  /**
   * Generate natural language summary
   * @private
   */
  _generateSummaryText(meetData, topPerformers, teamStats, sport) {
    const teams = Object.keys(teamStats);
    const topTeam = teams.length > 0 ? teams[0] : 'No teams';

    let text = `${meetData.name} took place on ${meetData.date || 'date TBD'} at ${meetData.location || 'TBD'}. `;

    if (topPerformers.length > 0) {
      const leader = topPerformers[0];
      text += `${leader.name || 'The top competitor'} led the field with an impressive performance. `;
    }

    text += `${teams.length} teams competed with ${Object.values(teamStats).reduce((sum, t) => sum + t.athletes, 0)} total athletes. `;

    if (sport === 'xc' && Object.keys(teamStats).length > 0) {
      const scores = Object.entries(teamStats).map(([name, stats]) => ({
        name,
        score: stats.score || 0
      }));
      if (scores[0]) {
        text += `${scores[0].name} took the team title. `;
      }
    }

    return text;
  }

  /**
   * Generate key highlights
   * @private
   */
  _generateHighlights(topPerformers, teamStats, sport) {
    const highlights = [];

    if (topPerformers.length > 0) {
      highlights.push(
        `üèÜ ${topPerformers[0].name || 'Top Athlete'} earned first place`
      );
    }

    if (topPerformers.length > 1) {
      highlights.push(
        `ü•à ${topPerformers[1].name || 'Second Place'} finished strong in second`
      );
    }

    const teamCount = Object.keys(teamStats).length;
    if (teamCount > 0) {
      highlights.push(`üè´ ${teamCount} teams participated`);
    }

    return highlights;
  }

  /**
   * Compare current performance to historical averages
   * @private
   */
  async _compareToHistorical(sport, athleteId, eventType) {
    try {
      const historicalRef = `${sport}/athleteHistory/${athleteId}`;
      const snapshot = await this.db.ref(historicalRef).once('value');
      const history = snapshot.val() || {};

      return {
        pastAverage: history.average || null,
        personalBest: history.best || null,
        totalRaces: history.races || 0
      };
    } catch (error) {
      console.warn('Could not fetch historical data:', error);
      return null;
    }
  }
}

// Export for use in admin interface
if (typeof module !== 'undefined' && module.exports) {
  module.exports = MeetAnalytics;
}
