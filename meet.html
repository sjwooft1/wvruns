<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Meet Results</title>
  <link rel="icon" type="image/png" href="assets/Favicon Generator/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="assets/Favicon Generator/favicon.svg" />
  <link rel="shortcut icon" href="assets/Favicon Generator/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="assets/Favicon Generator/apple-touch-icon.png" />
  <link rel="manifest" href="assets/Favicon Generator/site.webmanifest" />
  <link rel="stylesheet" href="style.css" />
  <style>
    #meet-title {
      color: white;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
      margin-bottom: 20px;
    }
    #meet-meta {
      color: rgba(255, 255, 255, 0.95);
      font-size: 1.1rem;
      margin-bottom: 30px;
      text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.2);
    }
    #results-box section {
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(10px);
    }
    #results-box table {
      border: none;
    }
    #results-box table th {
      background: linear-gradient(135deg, #002855 0%, #004080 100%);
      color: white;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
    }
    #results-box table td {
      border-bottom: 1px solid #e5e7eb;
    }
    @media (max-width: 768px) {
      table {
        font-size: 0.85rem;
      }
      table th,
      table td {
        padding: 8px 6px;
      }
      section h2 {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <div class="page-background"></div>
    <img src="assets/meets background.jpg" alt="" class="page-background-image" />
    <header>
    <a href="meets.html" style="color: white; text-decoration: none; font-weight: 600; padding: 8px 16px; border-radius: 8px; background: rgba(255,255,255,0.1); transition: all 0.3s ease;">← Back to Meets</a>
    <nav>
      <a href="index.html">Home</a>
      <a href="schools.html">Schools</a>
      <a href="meets.html">Meets</a>
      <a href="rankings.html">Rankings</a>
      <a href="calendar.html">Calendar</a>
    </nav>
  </header>
  <main>
    <h1 id="meet-title">Meet Results</h1>
    <div id="meet-meta"></div>
    <div id="error" style="color:red;display:none;"></div>
    <div id="results-box"></div>
  </main>
  <footer>
    <p>&copy; 2025 Mountain State Miles — Built by runners, for runners.</p>
    <a href="login.html"
       style="
         display:inline-block;
         margin-top:8px;
         background:#6cb5d967;
         padding:8px 14px;
         color:white;
         text-decoration:none;
         border-radius:6px;
         font-weight:bold;
       ">
       Admin Login
    </a>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase-config.js"></script>
  <script>
    const schoolNameCache = {};
    
    async function getMeetBySlug(slug) {
      const { data, error } = await supabase.from('meets').select('*').eq('slug', slug).single();
      if (error) return null;
      return data;
    }
    async function getResultsByMeet(meetSlug) {
      const { data, error } = await supabase.from('results').select('*').eq('meet_slug', meetSlug);
      if (error) return [];
      return data || [];
    }
    async function getSchoolNameBySlug(slug) {
      if (!slug) return slug || '';
      if (schoolNameCache[slug]) return schoolNameCache[slug];
      const { data, error } = await supabase.from('schools').select('name').eq('slug', slug).single();
      if (error || !data) {
        schoolNameCache[slug] = slug;
        return slug;
      }
      schoolNameCache[slug] = data.name;
      return data.name;
    }
    async function getSchoolNames(slugs) {
      const uniqueSlugs = [...new Set(slugs.filter(s => s))];
      const results = await Promise.all(uniqueSlugs.map(slug => getSchoolNameBySlug(slug)));
      const nameMap = {};
      uniqueSlugs.forEach((slug, i) => {
        nameMap[slug] = results[i];
      });
      return nameMap;
    }
    function formatTime(seconds) {
      if (!seconds && seconds !== 0) return '';
      const sec = Number(seconds);
      if (Number.isNaN(sec)) return seconds;
      const ms = Math.floor((sec % 1) * 100);
      const totalSeconds = Math.floor(sec);
      const minutes = Math.floor(totalSeconds / 60);
      const remainingSeconds = totalSeconds % 60;
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    }
    // Format grade from graduation year
    function formatGrade(gradYear) {
      if (!gradYear) return 'N/A';
      const yearNum = parseInt(gradYear, 10);
      if (Number.isNaN(yearNum)) return 'N/A';
      const now = new Date();
      const month = now.getMonth();
      const currentYear = now.getFullYear();
      const academicEndYear = month >= 7 ? currentYear + 1 : currentYear;
      const gradeNum = 12 - (yearNum - academicEndYear);
      const numLabels = { 9: '9th', 10: '10th', 11: '11th', 12: '12th' };
      return numLabels[gradeNum] || 'N/A';
    }
    // Calculate pace per mile for 5000 meters (3.10686 miles)
    function calculatePacePerMile(seconds) {
      if (!seconds && seconds !== 0) return '';
      const sec = Number(seconds);
      if (Number.isNaN(sec) || sec <= 0) return '';
      const DISTANCE_MILES = 3.10686; // 5000 meters in miles
      const paceSecondsPerMile = sec / DISTANCE_MILES;
      const paceMinutes = Math.floor(paceSecondsPerMile / 60);
      const paceSeconds = Math.floor(paceSecondsPerMile % 60);
      return `${paceMinutes}:${paceSeconds.toString().padStart(2, '0')}`;
    }
    function calculateTeamScores(results) {
      // Sort by place (asc), then by time (asc) if no place
      const sorted = [...results].sort((a,b)=>{
        const ap = a.place ? Number(a.place) : null;
        const bp = b.place ? Number(b.place) : null;
        if (ap && bp) return ap - bp;
        if (ap && !bp) return -1;
        if (!ap && bp) return 1;
        const at = Number(a.time);
        const bt = Number(b.time);
        if (!Number.isNaN(at) && !Number.isNaN(bt)) return at - bt;
        return 0;
      });
      
      // Assign place if missing (1-based, so 1st = 0 points, 2nd = 1 point, etc.)
      let currentPlace = 1;
      sorted.forEach((r, idx) => {
        if (!r.place) {
          r.place = currentPlace;
        } else {
          currentPlace = Number(r.place);
        }
        currentPlace++;
      });
      
      // Group by school
      const teams = {};
      sorted.forEach(r => {
        const school = r.school_slug || 'unknown';
        if (!teams[school]) {
          teams[school] = [];
        }
        teams[school].push(r);
      });
      
      // Calculate scores for each team
      const teamScores = [];
      for (const [schoolSlug, runners] of Object.entries(teams)) {
        // Sort runners by place
        const sortedRunners = [...runners].sort((a, b) => Number(a.place) - Number(b.place));
        
        // Get top 5 scores (1st = 1, 2nd = 2, 3rd = 3, etc.)
        const top5 = sortedRunners.slice(0, 5);
        const top5Scores = top5.map(r => Number(r.place));
        const top5Total = top5Scores.reduce((sum, score) => sum + score, 0);
        
        // Get 6th and 7th runner scores if available (for tiebreaker)
        const sixthRunner = sortedRunners[5]; // index 5 = 6th runner (0-indexed)
        const seventhRunner = sortedRunners[6]; // index 6 = 7th runner (0-indexed)
        const sixthScore = sixthRunner ? Number(sixthRunner.place) : null;
        const seventhScore = seventhRunner ? Number(seventhRunner.place) : null;
        
        teamScores.push({
          schoolSlug,
          runners: sortedRunners,
          top5: top5,
          top5Total,
          sixthScore,
          seventhScore,
          total: top5Total
        });
      }
      
      // Check for ties and calculate 7-runner totals if needed
      const teamScoresWithTiebreaker = teamScores.map(team => {
        // Calculate sum of all 7 runners if available (for tiebreaker)
        const top7 = team.runners.slice(0, 7);
        const top7Scores = top7.map(r => Number(r.place));
        const top7Total = top7Scores.reduce((sum, score) => sum + score, 0);
        return {
          ...team,
          top7Total: top7.length >= 7 ? top7Total : null
        };
      });
      
      // Sort by total score (ascending - lower is better)
      teamScoresWithTiebreaker.sort((a, b) => {
        if (a.total !== b.total) return a.total - b.total;
        // If tied on top 5, use sum of all 7 runners' scores
        if (a.top7Total !== null && b.top7Total !== null) {
          return a.top7Total - b.top7Total;
        }
        if (a.top7Total !== null) return -1;
        if (b.top7Total !== null) return 1;
        return 0;
      });
      
      return teamScoresWithTiebreaker;
    }
    async function renderTable(title, rows, schoolNames) {
      if (!rows.length) return '';
      // sort by place (asc when present), then by time (asc)
      const sorted = [...rows].sort((a,b)=>{
        const ap = a.place ? Number(a.place) : null;
        const bp = b.place ? Number(b.place) : null;
        if (ap && bp) return ap - bp;
        if (ap && !bp) return -1;
        if (!ap && bp) return 1;
        const at = Number(a.time);
        const bt = Number(b.time);
        if (!Number.isNaN(at) && !Number.isNaN(bt)) return at - bt;
        return 0;
      });
      
      // Calculate team scores
      const teamScores = calculateTeamScores(rows);
      
      // Get athlete grades
      const athleteGradeCache = {};
      const body = await Promise.all(sorted.map(async (r) => {
        let grade = 'N/A';
        if (r.athlete_name) {
          if (!athleteGradeCache[r.athlete_name]) {
            const { data } = await supabase
              .from('athletes')
              .select('grade')
              .ilike('name', r.athlete_name)
              .limit(1)
              .single();
            if (data) athleteGradeCache[r.athlete_name] = data.grade;
          }
          grade = formatGrade(athleteGradeCache[r.athlete_name]);
        }
        return `
          <tr>
            <td>${r.place || ''}</td>
            <td><a href="athlete.html?name=${encodeURIComponent(r.athlete_name || '')}" style="color: #0056b3; text-decoration: none; font-weight: 600;">${r.athlete_name || ''}</a></td>
            <td>${grade}</td>
            <td>${schoolNames[r.school_slug] || r.school_slug || ''}</td>
            <td>${formatTime(r.time)}</td>
            <td>${calculatePacePerMile(r.time)}</td>
          </tr>
        `;
      }));
      
      const bodyHtml = body.join('');
      
      // Separate teams by runner count
      const teamsWith5Plus = teamScores.filter(team => team.runners.length >= 5);
      const teamsUnder5 = teamScores.filter(team => team.runners.length < 5);
      
      // Create team scores table for teams with 5+ runners
      let teamScoresHtml = '';
      if (teamsWith5Plus.length > 0) {
        teamScoresHtml = `
          <h3 style="margin-top: 1.5em; color: #002855; font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5em;">Team Scores</h3>
          <p style="font-size: 0.95em; color: #666; margin-bottom: 1em; padding-left: 5px;">
            *7-Runner Total is used as a tiebreaker when teams are tied on top 5 scores.
          </p>
          <table style="width:100%;border-collapse:collapse;margin-bottom:1.5em;border-radius:12px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,0.1);">
            <thead>
              <tr>
                <th>Place</th>
                <th>Team</th>
                <th>Score (Top 5)</th>
                <th>7-Runner Total*</th>
              </tr>
            </thead>
            <tbody>
              ${teamsWith5Plus.map((team, idx) => {
                // Check if this team is tied with the previous team
                const isTied = idx > 0 && teamsWith5Plus[idx - 1].total === team.total;
                return `
                <tr>
                  <td>${idx + 1}</td>
                  <td>${schoolNames[team.schoolSlug] || team.schoolSlug}</td>
                  <td>${team.total}</td>
                  <td>${team.top7Total !== null ? team.top7Total : '—'}</td>
                </tr>
              `;
              }).join('')}
            </tbody>
          </table>
        `;
      }
      
      // Create table for teams with fewer than 5 runners
      let underFiveRunnersHtml = '';
      if (teamsUnder5.length > 0) {
        underFiveRunnersHtml = `
          <h3 style="margin-top: 1.5em; color: #002855; font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5em;">Under Five Runners</h3>
          <p style="font-size: 0.95em; color: #666; margin-bottom: 1em; padding-left: 5px;">
            Teams with fewer than 5 runners are not eligible for team scoring.
          </p>
          <table style="width:100%;border-collapse:collapse;margin-bottom:1.5em;border-radius:12px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,0.1);">
            <thead>
              <tr>
                <th>Team</th>
                <th>Runners</th>
              </tr>
            </thead>
            <tbody>
              ${teamsUnder5.map((team) => {
                return `
                <tr>
                  <td>${schoolNames[team.schoolSlug] || team.schoolSlug}</td>
                  <td>${team.runners.length}</td>
                </tr>
              `;
              }).join('')}
            </tbody>
          </table>
        `;
      }
      
      return `
        <section style="margin: 2em 0;">
          <h2>${title}</h2>
          ${teamScoresHtml}
          ${underFiveRunnersHtml}
          <table style="width:100%;border-collapse:collapse;border-radius:12px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,0.1);">
            <thead>
              <tr>
                <th>Place</th>
                <th>Athlete</th>
                <th>Grade</th>
                <th>School</th>
                <th>Time</th>
                <th>Pace/Mile</th>
              </tr>
            </thead>
            <tbody>${bodyHtml}</tbody>
          </table>
        </section>
      `;
    }
    function formatDate(dateString) {
      if (!dateString) return '';
      // Parse date string in local time to avoid timezone shift
      const parts = dateString.split('-');
      if (parts.length === 3) {
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
        const day = parseInt(parts[2], 10);
        const date = new Date(year, month, day);
        return date.toLocaleDateString();
      }
      // Fallback to original method if format is unexpected
      return new Date(dateString).toLocaleDateString();
    }
    async function loadMeetPage() {
      const params = new URLSearchParams(window.location.search);
      const slug = params.get('slug');
      const errorDiv = document.getElementById('error');
      if (!slug) {
        errorDiv.textContent = 'No meet specified!';
        errorDiv.style.display = '';
        return;
      }
      const meet = await getMeetBySlug(slug);
      if (!meet) {
        errorDiv.textContent = 'Meet not found!';
        errorDiv.style.display = '';
        return;
      }
      document.getElementById('meet-title').textContent = meet.name || slug;
      document.getElementById('meet-meta').innerHTML = `
        ${meet.date ? 'Date: ' + formatDate(meet.date) + '<br>' : ''}
        ${meet.location ? 'Location: ' + meet.location + '<br>' : ''}
        ${meet.description ? meet.description + '<br>' : ''}
      `;
      const results = await getResultsByMeet(slug);
      const container = document.getElementById('results-box');
      if (!results.length) {
        container.innerHTML = '<p>No results for this meet.</p>';
        return;
      }
      const male = results.filter(r => (r.gender || '').toString().toUpperCase() === 'M');
      const female = results.filter(r => (r.gender || '').toString().toUpperCase() === 'F');
      const other = results.filter(r => !r.gender || !['M','F'].includes(r.gender.toString().toUpperCase()));
      
      // Get all school names
      const allSlugs = [...new Set(results.map(r => r.school_slug).filter(s => s))];
      const schoolNames = await getSchoolNames(allSlugs);
      
      let html = '';
      if (male.length) {
        html += await renderTable('Male Results', male, schoolNames);
      }
      if (female.length) {
        html += await renderTable('Female Results', female, schoolNames);
      }
      if (!male.length && !female.length) {
        html += await renderTable('Results', other, schoolNames);
      }
      container.innerHTML = html || '<p>No results for this meet.</p>';
    }
    loadMeetPage();
  </script>
  </div>
</body>
</html>
