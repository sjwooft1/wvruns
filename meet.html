<!DOCTYPE html>
<html lang="en">
  <script>
    window.addEventListener("DOMContentLoaded", () => {
      const params = new URLSearchParams(window.location.search);
      const slug = params.get("slug");
      if (slug) {
        document.title = `${slug.replace(/-/g, " ")} – Meet Results | Mountain State Miles`;
      }
    });
  </script>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Meet Results</title>
  <link rel="icon" type="image/png" href="assets/Favicon Generator/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="assets/Favicon Generator/favicon.svg" />
  <link rel="shortcut icon" href="assets/Favicon Generator/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="assets/Favicon Generator/apple-touch-icon.png" />
  <link rel="manifest" href="assets/Favicon Generator/site.webmanifest" />
  <link rel="stylesheet" href="style.css" />
  <meta name="description" content="WV running results, rankings, times, rosters, and meet data — Mountain State Miles." />
  <meta name="keywords" content="WVXC, WV Track, West Virginia Running, Cross Country Results, WV HS Running, Mountain State Miles" />
  <meta name="author" content="Mountain State Miles" />

  <style>
    /* Lightweight page-specific styling */
    .tabs-row {
      display: flex;
      gap: 10px;
      margin: 18px 0;
      align-items: center;
    }
    .gender-tab {
      padding: 10px 16px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      color: white;
      cursor: pointer;
      font-weight: 700;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .gender-tab.active {
      background: #ffffff;
      color: #002855;
      box-shadow: 0 6px 18px rgba(2,40,80,0.12);
    }
    .race-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .race-button {
      padding: 14px 12px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.95rem;
      box-shadow: 0 3px 8px rgba(0,0,0,0.12);
    }
    .race-button.primary { background: #002855; color: white; }
    .race-button.secondary { background: #f1f5f9; color: #002855; }
    #selector-card {
      background: rgba(255,255,255,0.03);
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 22px;
      border: 1px solid rgba(255,255,255,0.04);
    }
    #select-heading {
      color: white;
      font-size: 1.25rem;
      margin-bottom: 6px;
    }
    #select-sub {
      color: rgba(255,255,255,0.8);
      margin-bottom: 12px;
    }
    @media (max-width: 700px) {
      .race-buttons { grid-template-columns: 1fr; }
    }
    /* ensure results area looks consistent */
    #results-box section { background: rgba(255,255,255,0.98); backdrop-filter: blur(10px); }
  </style>
</head>

<body>
  <div class="content-wrapper">
    <div class="page-background"></div>
    <img src="assets/meets background.jpg" alt="" class="page-background-image" />
    <header>
      <a href="meets.html" style="color: white; text-decoration: none; font-weight: 600; padding: 8px 16px; border-radius: 8px; background: rgba(255,255,255,0.1); transition: all 0.3s ease;">← Back to Meets</a>
      <nav>
        <a href="index.html">Home</a>
        <a href="schools.html">Schools</a>
        <a href="meets.html">Meets</a>
        <a href="rankings.html">Rankings</a>
        <a href="calendar.html">Calendar</a>
      </nav>
    </header>

    <main>
      <h1 id="meet-title">Meet Results</h1>
      <div id="meet-meta"></div>
      <div id="error" style="color:red;display:none;"></div>

      <!-- Selection area (tabs + buttons) -->
      <div id="selector" style="display:none;">
        <div id="selector-card">
          <div class="tabs-row" role="tablist" aria-label="Gender tabs">
            <button id="tab-boys" class="gender-tab">BOYS</button>
            <button id="tab-girls" class="gender-tab">GIRLS</button>
            <button id="tab-other" class="gender-tab">OTHER</button>
          </div>
          <div id="select-heading">Select a Race</div>
          <div id="select-sub">Choose which race results you want to view for this meet.</div>
          <div id="race-button-wrap"></div>
        </div>
      </div>

      <div id="results-box"></div>
    </main>

    <footer>
      <p>&copy; 2025 Mountain State Miles — Built by runners, for runners.</p>
      <a href="login.html"
         style="
           display:inline-block;
           margin-top:8px;
           background:#6cb5d967;
           padding:8px 14px;
           color:white;
           text-decoration:none;
           border-radius:6px;
           font-weight:bold;
         ">
         Admin Login
      </a>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase-config.js"></script>

  <script>
    // -----------------------
    // Helper functions (from your original file)
    // -----------------------
    const schoolNameCache = {};

    async function getMeetBySlug(slug) {
      const { data, error } = await supabase.from('meets').select('*').eq('slug', slug).single();
      if (error) return null;
      return data;
    }
    async function getResultsByMeet(meetSlug) {
      const { data, error } = await supabase.from('results').select('*').eq('meet_slug', meetSlug);
      if (error) return [];
      return data || [];
    }
    async function getSchoolNameBySlug(slug) {
      if (!slug) return slug || '';
      if (schoolNameCache[slug]) return schoolNameCache[slug];
      const { data, error } = await supabase.from('schools').select('name').eq('slug', slug).single();
      if (error || !data) {
        schoolNameCache[slug] = slug;
        return slug;
      }
      schoolNameCache[slug] = data.name;
      return data.name;
    }
    async function getSchoolNames(slugs) {
      const uniqueSlugs = [...new Set(slugs.filter(s => s))];
      const results = await Promise.all(uniqueSlugs.map(slug => getSchoolNameBySlug(slug)));
      const nameMap = {};
      uniqueSlugs.forEach((slug, i) => {
        nameMap[slug] = results[i];
      });
      return nameMap;
    }
    function formatTime(seconds) {
      if (!seconds && seconds !== 0) return '';
      const sec = Number(seconds);
      if (Number.isNaN(sec)) return seconds;
      const ms = Math.floor((sec % 1) * 100);
      const totalSeconds = Math.floor(sec);
      const minutes = Math.floor(totalSeconds / 60);
      const remainingSeconds = totalSeconds % 60;
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    }
    function formatGrade(gradYear) {
      if (!gradYear) return 'N/A';
      const yearNum = parseInt(gradYear, 10);
      if (Number.isNaN(yearNum)) return 'N/A';
      const now = new Date();
      const month = now.getMonth();
      const currentYear = now.getFullYear();
      const academicEndYear = month >= 7 ? currentYear + 1 : currentYear;
      const gradeNum = 12 - (yearNum - academicEndYear);
      const numLabels = { 9: '9th', 10: '10th', 11: '11th', 12: '12th' };
      return numLabels[gradeNum] || 'N/A';
    }
    function calculatePacePerMile(seconds) {
      if (!seconds && seconds !== 0) return '';
      const sec = Number(seconds);
      if (Number.isNaN(sec) || sec <= 0) return '';
      const DISTANCE_MILES = 3.10686; // 5000 meters in miles
      const paceSecondsPerMile = sec / DISTANCE_MILES;
      const paceMinutes = Math.floor(paceSecondsPerMile / 60);
      const paceSeconds = Math.floor(paceSecondsPerMile % 60);
      return `${paceMinutes}:${paceSeconds.toString().padStart(2, '0')}`;
    }

    // team scoring preserved
    function calculateTeamScores(results) {
      const sorted = [...results].sort((a,b)=>{
        const ap = a.place ? Number(a.place) : null;
        const bp = b.place ? Number(b.place) : null;
        if (ap && bp) return ap - bp;
        if (ap && !bp) return -1;
        if (!ap && bp) return 1;
        const at = Number(a.time);
        const bt = Number(b.time);
        if (!Number.isNaN(at) && !Number.isNaN(bt)) return at - bt;
        return 0;
      });
      let currentPlace = 1;
      sorted.forEach((r, idx) => {
        if (!r.place) {
          r.place = currentPlace;
        } else {
          currentPlace = Number(r.place);
        }
        currentPlace++;
      });
      const teams = {};
      sorted.forEach(r => {
        const school = r.school_slug || 'unknown';
        if (!teams[school]) teams[school] = [];
        teams[school].push(r);
      });
      const teamScores = [];
      for (const [schoolSlug, runners] of Object.entries(teams)) {
        const sortedRunners = [...runners].sort((a, b) => Number(a.place) - Number(b.place));
        const top5 = sortedRunners.slice(0, 5);
        const top5Scores = top5.map(r => Number(r.place));
        const top5Total = top5Scores.reduce((sum, score) => sum + score, 0);
        const sixthRunner = sortedRunners[5];
        const seventhRunner = sortedRunners[6];
        const sixthScore = sixthRunner ? Number(sixthRunner.place) : null;
        const seventhScore = seventhRunner ? Number(seventhRunner.place) : null;
        teamScores.push({
          schoolSlug,
          runners: sortedRunners,
          top5: top5,
          top5Total,
          sixthScore,
          seventhScore,
          total: top5Total
        });
      }
      const teamScoresWithTiebreaker = teamScores.map(team => {
        const top7 = team.runners.slice(0, 7);
        const top7Scores = top7.map(r => Number(r.place));
        const top7Total = top7Scores.reduce((sum, score) => sum + score, 0);
        return { ...team, top7Total: top7.length >= 7 ? top7Total : null };
      });
      teamScoresWithTiebreaker.sort((a, b) => {
        if (a.total !== b.total) return a.total - b.total;
        if (a.top7Total !== null && b.top7Total !== null) return a.top7Total - b.top7Total;
        if (a.top7Total !== null) return -1;
        if (b.top7Total !== null) return 1;
        return 0;
      });
      return teamScoresWithTiebreaker;
    }

    // Render table (keeps existing look/logic, returns HTML string)
    async function renderTable(title, rows, schoolNames) {
      if (!rows.length) return '';
      const sorted = [...rows].sort((a,b)=>{
        const ap = a.place ? Number(a.place) : null;
        const bp = b.place ? Number(b.place) : null;
        if (ap && bp) return ap - bp;
        if (ap && !bp) return -1;
        if (!ap && bp) return 1;
        const at = Number(a.time);
        const bt = Number(b.time);
        if (!Number.isNaN(at) && !Number.isNaN(bt)) return at - bt;
        return 0;
      });

      const teamScores = calculateTeamScores(rows);
      const athleteGradeCache = {};
      const body = await Promise.all(sorted.map(async (r) => {
        let grade = 'N/A';
        if (r.athlete_name) {
          if (!athleteGradeCache[r.athlete_name]) {
            const { data } = await supabase
              .from('athletes')
              .select('grade')
              .ilike('name', r.athlete_name)
              .limit(1)
              .single();
            if (data) athleteGradeCache[r.athlete_name] = data.grade;
          }
          grade = formatGrade(athleteGradeCache[r.athlete_name]);
        }
        return `
          <tr>
            <td>${r.place || ''}</td>
            <td><a href="athlete.html?name=${encodeURIComponent(r.athlete_name || '')}" style="color: #0056b3; text-decoration: none; font-weight: 600;">${r.athlete_name || ''}</a></td>
            <td>${grade}</td>
            <td>${schoolNames[r.school_slug] || r.school_slug || ''}</td>
            <td>${formatTime(r.time)}</td>
            <td>${calculatePacePerMile(r.time)}</td>
          </tr>
        `;
      }));

      const bodyHtml = body.join('');
      const teamsWith5Plus = teamScores.filter(team => team.runners.length >= 5);
      const teamsUnder5 = teamScores.filter(team => team.runners.length < 5);

      let teamScoresHtml = '';
      if (teamsWith5Plus.length > 0) {
        teamScoresHtml = `
          <h3 style="margin-top: 1.5em; color: #002855; font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5em;">Team Scores</h3>
          <p style="font-size: 0.95em; color: #666; margin-bottom: 1em; padding-left: 5px;">
            *7-Runner Total is used as a tiebreaker when teams are tied on top 5 scores.
          </p>
          <table style="width:100%;border-collapse:collapse;margin-bottom:1.5em;border-radius:12px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,0.1);">
            <thead>
              <tr>
                <th>Place</th>
                <th>Team</th>
                <th>Score (Top 5)</th>
                <th>7-Runner Total*</th>
              </tr>
            </thead>
            <tbody>
              ${teamsWith5Plus.map((team, idx) => {
                return `
                <tr>
                  <td>${idx + 1}</td>
                  <td>${schoolNames[team.schoolSlug] || team.schoolSlug}</td>
                  <td>${team.total}</td>
                  <td>${team.top7Total !== null ? team.top7Total : '—'}</td>
                </tr>
              `;
              }).join('')}
            </tbody>
          </table>
        `;
      }

      let underFiveRunnersHtml = '';
      if (teamsUnder5.length > 0) {
        underFiveRunnersHtml = `
          <h3 style="margin-top: 1.5em; color: #002855; font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5em;">Under Five Runners</h3>
          <p style="font-size: 0.95em; color: #666; margin-bottom: 1em; padding-left: 5px;">
            Teams with fewer than 5 runners are not eligible for team scoring.
          </p>
          <table style="width:100%;border-collapse:collapse;margin-bottom:1.5em;border-radius:12px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,0.1);">
            <thead>
              <tr>
                <th>Team</th>
                <th>Runners</th>
              </tr>
            </thead>
            <tbody>
              ${teamsUnder5.map((team) => {
                return `
                <tr>
                  <td>${schoolNames[team.schoolSlug] || team.schoolSlug}</td>
                  <td>${team.runners.length}</td>
                </tr>
              `;
              }).join('')}
            </tbody>
          </table>
        `;
      }

      return `
        <section style="margin: 2em 0;">
          <h2>${title}</h2>
          ${teamScoresHtml}
          ${underFiveRunnersHtml}
          <table style="width:100%;border-collapse:collapse;border-radius:12px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,0.1);">
            <thead>
              <tr>
                <th>Place</th>
                <th>Athlete</th>
                <th>Grade</th>
                <th>School</th>
                <th>Time</th>
                <th>Pace/Mile</th>
              </tr>
            </thead>
            <tbody>${bodyHtml}</tbody>
          </table>
        </section>
      `;
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      const parts = dateString.split('-');
      if (parts.length === 3) {
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1;
        const day = parseInt(parts[2], 10);
        const date = new Date(year, month, day);
        return date.toLocaleDateString();
      }
      return new Date(dateString).toLocaleDateString();
    }

    // -----------------------
    // New UI helpers for race / tab selection
    // -----------------------
    function humanizeRaceType(raw) {
      if (!raw) return 'Varsity';
      const s = raw.toString();
      if (s === 'varsity') return 'Varsity';
      if (s === 'elite') return 'Elite';
      if (s === 'jv') return 'JV';
      if (s === 'open') return 'Open';
      if (s === 'emerging-elite') return 'Emerging Elite';
      // fallback: capitalize words
      return s.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function genderLabel(g) {
      if (!g) return 'Other';
      const gg = g.toString().toUpperCase();
      if (gg === 'M') return 'Boys';
      if (gg === 'F') return 'Girls';
      return 'Other';
    }

    function buildGenderTabs() {
      const tabB = document.getElementById('tab-boys');
      const tabG = document.getElementById('tab-girls');
      const tabO = document.getElementById('tab-other');
      // attach basic click handlers (they will be enabled only when groups exist)
      [tabB, tabG, tabO].forEach(t => {
        t.onclick = () => {
          document.querySelectorAll('.gender-tab').forEach(el => el.classList.remove('active'));
          t.classList.add('active');
          renderRaceButtonsForTab(t.dataset.key || '');
        };
      });
    }

    function createRaceButton(label, count, styleClass = 'primary') {
      const btn = document.createElement('button');
      btn.className = `race-button ${styleClass}`;
      btn.innerHTML = `<div style="font-weight:800;">${label}</div><div style="font-size:0.85rem; font-weight:600; margin-top:6px; color:${styleClass === 'primary' ? 'rgba(255,255,255,0.85)' : '#003067'}">${count} runners</div>`;
      return btn;
    }

    let GLOBAL_GROUPS = {}; // groups keyed by gender->raceType
    let SCHOOL_NAMES_CACHE = {}; // used when rendering

    async function renderRaceButtonsForTab(key) {
      // key = 'M' or 'F' or 'OTHER'
      const wrap = document.getElementById('race-button-wrap');
      wrap.innerHTML = '';
      const entries = Object.entries(GLOBAL_GROUPS).filter(([k, v]) => {
        // k format: "M::varsity" or "F::jv" or "OTHER::open"
        const [g, r] = k.split('::');
        if (key === 'M') return g === 'M';
        if (key === 'F') return g === 'F';
        return g === 'OTHER';
      });

      if (!entries.length) {
        wrap.innerHTML = '<div style="color:rgba(255,255,255,0.8);">No races found for this category.</div>';
        return;
      }

      // For visual ordering, sort by preferred race types (varsity, elite, jv, open, emerging-elite)
      const order = ['varsity', 'elite', 'jv', 'open', 'emerging-elite'];
      entries.sort((a,b)=>{
        const ra = a[0].split('::')[1];
        const rb = b[0].split('::')[1];
        const ia = order.indexOf(ra) === -1 ? 99 : order.indexOf(ra);
        const ib = order.indexOf(rb) === -1 ? 99 : order.indexOf(rb);
        return ia - ib;
      });

      entries.forEach(([k, v]) => {
        const [g, race] = k.split('::');
        const label = `${genderLabel(g)} ${humanizeRaceType(race)}`;
        const btn = createRaceButton(label, v.rows.length, 'primary');
        btn.onclick = () => {
          const container = document.getElementById('results-box');
          container.innerHTML = v.html || '<p>Loading...</p>';
          // smooth scroll to results
          setTimeout(()=> {
            container.scrollIntoView({ behavior: 'smooth' });
          }, 50);
        };
        wrap.appendChild(btn);
      });
    }

    // Build the groups and prepare HTML for each race (but don't render results yet)
    async function buildGroupsAndPrepareHtml(results, schoolNames) {
      // results: array of result objects
      // build groups keyed by `${gender}::${race_type}`
      const groups = {};
      results.forEach(r => {
        const genderRaw = (r.gender || '').toString().toUpperCase();
        const genderKey = (genderRaw === 'M' || genderRaw === 'F') ? genderRaw : 'OTHER';
        const raceType = (r.race_type || 'varsity').toString().toLowerCase();
        const key = `${genderKey}::${raceType}`;
        if (!groups[key]) groups[key] = { gender: genderKey, race_type: raceType, rows: [] };
        groups[key].rows.push(r);
      });

      // Prepare HTML for each group using renderTable
      const prepared = {};
      const keys = Object.keys(groups);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const g = groups[k];
        prepared[k] = {
          gender: g.gender,
          race_type: g.race_type,
          rows: g.rows,
          html: await renderTable(`${genderLabel(g.gender)} ${humanizeRaceType(g.race_type)}`, g.rows, schoolNames)
        };
      }
      return prepared;
    }

    // -----------------------
    // Main load function
    // -----------------------
    async function loadMeetPage() {
      const params = new URLSearchParams(window.location.search);
      const slug = params.get('slug');
      const errorDiv = document.getElementById('error');
      if (!slug) {
        errorDiv.textContent = 'No meet specified!';
        errorDiv.style.display = '';
        return;
      }
      const meet = await getMeetBySlug(slug);
      if (!meet) {
        errorDiv.textContent = 'Meet not found!';
        errorDiv.style.display = '';
        return;
      }
      document.getElementById('meet-title').textContent = meet.name || slug;
      document.getElementById('meet-meta').innerHTML = `
        ${meet.date ? 'Date: ' + formatDate(meet.date) + '<br>' : ''}
        ${meet.location ? 'Location: ' + meet.location + '<br>' : ''}
        ${meet.description ? meet.description + '<br>' : ''}
      `;

      // Fetch results
      const results = await getResultsByMeet(slug); // from supabase
      const container = document.getElementById('results-box');

      if (!results.length) {
        container.innerHTML = '<p>No results for this meet.</p>';
        return;
      }

      // Normalize missing race_type => varsity
      results.forEach(r => {
        if (!r.race_type) r.race_type = 'varsity';
      });

      // Get all school names
      const allSlugs = [...new Set(results.map(r => r.school_slug).filter(s => s))];
      const schoolNames = await getSchoolNames(allSlugs);
      SCHOOL_NAMES_CACHE = schoolNames;

      // Build groups and prepared HTML
      const groupsPrepared = await buildGroupsAndPrepareHtml(results, schoolNames);
      GLOBAL_GROUPS = groupsPrepared; // store globally for UI functions

      const groupKeys = Object.keys(groupsPrepared);
      // If there's only one group total, render results directly (no selector)
      if (groupKeys.length === 1) {
        const single = groupsPrepared[groupKeys[0]];
        container.innerHTML = single.html || '<p>No results.</p>';
        return;
      }

      // There are multiple groups -> show selector UI
      document.getElementById('selector').style.display = '';
      // enable / disable tabs depending on if groups exist for that gender
      const hasBoys = groupKeys.some(k => k.startsWith('M::'));
      const hasGirls = groupKeys.some(k => k.startsWith('F::'));
      const hasOther = groupKeys.some(k => k.startsWith('OTHER::'));

      const tabB = document.getElementById('tab-boys');
      const tabG = document.getElementById('tab-girls');
      const tabO = document.getElementById('tab-other');

      tabB.dataset.key = hasBoys ? 'M' : '';
      tabG.dataset.key = hasGirls ? 'F' : '';
      tabO.dataset.key = hasOther ? 'OTHER' : '';

      // toggle appearance
      [tabB, tabG, tabO].forEach(t => {
        t.style.display = t.dataset.key ? 'inline-block' : 'none';
        t.classList.remove('active');
      });

      // Setup handlers
      buildGenderTabs();

      // default to first visible tab (Boys -> Girls -> Other)
      if (hasBoys) tabB.click();
      else if (hasGirls) tabG.click();
      else tabO.click();
    }

    // Kickoff
    loadMeetPage();
  </script>
</body>
</html>
